/**
 * @packageDocumentation
 *
 * A Datastore implementation with a file system backend.
 *
 * @example
 *
 * ```js
 * import { FsDatastore } from 'datastore-fs'
 *
 * const store = new FsDatastore('path/to/store')
 * ```
 */
import fs from 'node:fs/promises';
import path from 'node:path';
import { BaseDatastore } from 'datastore-core';
import { Key } from 'interface-datastore';
import { OpenFailedError, NotFoundError, PutFailedError, DeleteFailedError } from 'interface-store';
import glob from 'it-glob';
import map from 'it-map';
import parallel from 'it-parallel-batch';
import { Writer } from 'steno';
/**
 * Write a file atomically
 */
async function writeFile(path, contents) {
    try {
        const writer = new Writer(path);
        await writer.write(contents);
    }
    catch (err) {
        if (err.syscall === 'rename' && ['ENOENT', 'EPERM'].includes(err.code)) {
            // steno writes a file to a temp location before renaming it.
            // If the final file already exists this error is thrown.
            // Make sure we can read & write to this file
            await fs.access(path, fs.constants.F_OK | fs.constants.W_OK);
            // The file was created by another context - this means there were
            // attempts to write the same block by two different function calls
            return;
        }
        throw err;
    }
}
/**
 * A datastore backed by the file system.
 *
 * Keys need to be sanitized before use, as they are written
 * to the file system as is.
 */
export class FsDatastore extends BaseDatastore {
    path;
    createIfMissing;
    errorIfExists;
    extension;
    deleteManyConcurrency;
    getManyConcurrency;
    putManyConcurrency;
    constructor(location, init = {}) {
        super();
        this.path = path.resolve(location);
        this.createIfMissing = init.createIfMissing ?? true;
        this.errorIfExists = init.errorIfExists ?? false;
        this.extension = init.extension ?? '.data';
        this.deleteManyConcurrency = init.deleteManyConcurrency ?? 50;
        this.getManyConcurrency = init.getManyConcurrency ?? 50;
        this.putManyConcurrency = init.putManyConcurrency ?? 50;
    }
    async open() {
        try {
            await fs.access(this.path, fs.constants.F_OK | fs.constants.W_OK);
            if (this.errorIfExists) {
                throw new OpenFailedError(`Datastore directory: ${this.path} already exists`);
            }
        }
        catch (err) {
            if (err.code === 'ENOENT') {
                if (this.createIfMissing) {
                    await fs.mkdir(this.path, { recursive: true });
                    return;
                }
                else {
                    throw new NotFoundError(`Datastore directory: ${this.path} does not exist`);
                }
            }
            throw err;
        }
    }
    async close() {
    }
    /**
     * Calculate the directory and file name for a given key.
     */
    _encode(key) {
        const parent = key.parent().toString();
        const dir = path.join(this.path, parent);
        const name = key.toString().slice(parent.length);
        const file = path.join(dir, name + this.extension);
        return {
            dir,
            file
        };
    }
    /**
     * Calculate the original key, given the file name.
     */
    _decode(file) {
        const ext = this.extension;
        if (path.extname(file) !== ext) {
            throw new Error(`Invalid extension: ${path.extname(file)}`);
        }
        const keyname = file
            .slice(this.path.length, -ext.length)
            .split(path.sep)
            .join('/');
        return new Key(keyname);
    }
    /**
     * Store the given value under the key
     */
    async put(key, val) {
        const parts = this._encode(key);
        try {
            await fs.mkdir(parts.dir, {
                recursive: true
            });
            await writeFile(parts.file, val);
            return key;
        }
        catch (err) {
            throw new PutFailedError(String(err));
        }
    }
    async *putMany(source) {
        yield* parallel(map(source, ({ key, value }) => {
            return async () => {
                await this.put(key, value);
                return key;
            };
        }), this.putManyConcurrency);
    }
    /**
     * Read from the file system
     */
    async get(key) {
        const parts = this._encode(key);
        let data;
        try {
            data = await fs.readFile(parts.file);
        }
        catch (err) {
            throw new NotFoundError(String(err));
        }
        return data;
    }
    async *getMany(source) {
        yield* parallel(map(source, key => {
            return async () => {
                return {
                    key,
                    value: await this.get(key)
                };
            };
        }), this.getManyConcurrency);
    }
    async *deleteMany(source) {
        yield* parallel(map(source, key => {
            return async () => {
                await this.delete(key);
                return key;
            };
        }), this.deleteManyConcurrency);
    }
    /**
     * Check for the existence of the given key
     */
    async has(key) {
        const parts = this._encode(key);
        try {
            await fs.access(parts.file);
        }
        catch (err) {
            return false;
        }
        return true;
    }
    /**
     * Delete the record under the given key
     */
    async delete(key) {
        const parts = this._encode(key);
        try {
            await fs.unlink(parts.file);
        }
        catch (err) {
            if (err.code === 'ENOENT') {
                return;
            }
            throw new DeleteFailedError(String(err));
        }
    }
    async *_all(q) {
        let prefix = q.prefix ?? '**';
        // strip leading slashes
        prefix = prefix.replace(/^\/+/, '');
        const pattern = `${prefix}/*${this.extension}`
            .split(path.sep)
            .join('/');
        const files = glob(this.path, pattern, {
            absolute: true
        });
        for await (const file of files) {
            try {
                const buf = await fs.readFile(file);
                const pair = {
                    key: this._decode(file),
                    value: buf
                };
                yield pair;
            }
            catch (err) {
                // if keys are removed from the datastore while the query is
                // running, we may encounter missing files.
                if (err.code !== 'ENOENT') {
                    throw err;
                }
            }
        }
    }
    async *_allKeys(q) {
        let prefix = q.prefix ?? '**';
        // strip leading slashes
        prefix = prefix.replace(/^\/+/, '');
        const pattern = `${prefix}/*${this.extension}`
            .split(path.sep)
            .join('/');
        const files = glob(this.path, pattern, {
            absolute: true
        });
        yield* map(files, f => this._decode(f));
    }
}
//# sourceMappingURL=index.js.map