import { serviceCapabilities, transportSymbol } from '@libp2p/interface';
import type { DataChannelOptions, TransportCertificate } from '../index.js';
import type { WebRTCDialEvents } from '../private-to-private/transport.js';
import type { CreateListenerOptions, Transport, Listener, ComponentLogger, Connection, CounterGroup, Metrics, PeerId, DialTransportOptions, PrivateKey, Upgrader } from '@libp2p/interface';
import type { TransportManager } from '@libp2p/interface-internal';
import type { Multiaddr } from '@multiformats/multiaddr';
/**
 * The peer for this transport
 */
export interface WebRTCDirectTransportComponents {
    peerId: PeerId;
    privateKey: PrivateKey;
    metrics?: Metrics;
    logger: ComponentLogger;
    transportManager: TransportManager;
    upgrader: Upgrader;
}
export interface WebRTCMetrics {
    dialerEvents: CounterGroup;
}
export interface WebRTCTransportDirectInit {
    rtcConfiguration?: RTCConfiguration | (() => RTCConfiguration | Promise<RTCConfiguration>);
    dataChannel?: DataChannelOptions;
    certificates?: TransportCertificate[];
    /**
     * @deprecated this setting is ignored and will be removed in a future release
     */
    useLibjuice?: boolean;
}
export declare class WebRTCDirectTransport implements Transport {
    private readonly log;
    private readonly metrics?;
    private readonly components;
    private readonly init;
    constructor(components: WebRTCDirectTransportComponents, init?: WebRTCTransportDirectInit);
    readonly [transportSymbol] = true;
    readonly [Symbol.toStringTag] = "@libp2p/webrtc-direct";
    readonly [serviceCapabilities]: string[];
    /**
     * Dial a given multiaddr
     */
    dial(ma: Multiaddr, options: DialTransportOptions<WebRTCDialEvents>): Promise<Connection>;
    /**
     * Create transport listeners no supported by browsers
     */
    createListener(options: CreateListenerOptions): Listener;
    /**
     * Filter check for all Multiaddrs that this transport can listen on
     */
    listenFilter(multiaddrs: Multiaddr[]): Multiaddr[];
    /**
     * Filter check for all Multiaddrs that this transport can dial
     */
    dialFilter(multiaddrs: Multiaddr[]): Multiaddr[];
    /**
     * Connect to a peer using a multiaddr
     */
    _connect(ma: Multiaddr, options: DialTransportOptions<WebRTCDialEvents>): Promise<Connection>;
}
//# sourceMappingURL=transport.d.ts.map