import { serviceCapabilities, transportSymbol } from '@libp2p/interface';
import { peerIdFromString } from '@libp2p/peer-id';
import { WebRTCDirect } from '@multiformats/multiaddr-matcher';
import { raceSignal } from 'race-signal';
import { genUfrag } from '../util.js';
import { WebRTCDirectListener } from './listener.js';
import { connect } from './utils/connect.js';
import { createDialerRTCPeerConnection } from './utils/get-rtcpeerconnection.js';
export class WebRTCDirectTransport {
    log;
    metrics;
    components;
    init;
    constructor(components, init = {}) {
        this.log = components.logger.forComponent('libp2p:webrtc-direct');
        this.components = components;
        this.init = init;
        if (components.metrics != null) {
            this.metrics = {
                dialerEvents: components.metrics.registerCounterGroup('libp2p_webrtc-direct_dialer_events_total', {
                    label: 'event',
                    help: 'Total count of WebRTC-direct dial events by type'
                })
            };
        }
    }
    [transportSymbol] = true;
    [Symbol.toStringTag] = '@libp2p/webrtc-direct';
    [serviceCapabilities] = [
        '@libp2p/transport'
    ];
    /**
     * Dial a given multiaddr
     */
    async dial(ma, options) {
        const rawConn = await this._connect(ma, options);
        this.log('dialing address: %a', ma);
        return rawConn;
    }
    /**
     * Create transport listeners no supported by browsers
     */
    createListener(options) {
        return new WebRTCDirectListener(this.components, {
            ...this.init,
            ...options
        });
    }
    /**
     * Filter check for all Multiaddrs that this transport can listen on
     */
    listenFilter(multiaddrs) {
        return multiaddrs.filter(WebRTCDirect.exactMatch);
    }
    /**
     * Filter check for all Multiaddrs that this transport can dial
     */
    dialFilter(multiaddrs) {
        return this.listenFilter(multiaddrs);
    }
    /**
     * Connect to a peer using a multiaddr
     */
    async _connect(ma, options) {
        // do not create RTCPeerConnection if the signal has already been aborted
        options.signal.throwIfAborted();
        let theirPeerId;
        const remotePeerString = ma.getPeerId();
        if (remotePeerString != null) {
            theirPeerId = peerIdFromString(remotePeerString);
        }
        const ufrag = genUfrag();
        // https://github.com/libp2p/specs/blob/master/webrtc/webrtc-direct.md#browser-to-public-server
        const peerConnection = await createDialerRTCPeerConnection('client', ufrag, typeof this.init.rtcConfiguration === 'function' ? await this.init.rtcConfiguration() : this.init.rtcConfiguration ?? {});
        try {
            return await raceSignal(connect(peerConnection, ufrag, {
                role: 'client',
                log: this.log,
                logger: this.components.logger,
                metrics: this.components.metrics,
                events: this.metrics?.dialerEvents,
                signal: options.signal,
                remoteAddr: ma,
                dataChannel: this.init.dataChannel,
                upgrader: options.upgrader,
                peerId: this.components.peerId,
                remotePeerId: theirPeerId,
                privateKey: this.components.privateKey
            }), options.signal);
        }
        catch (err) {
            peerConnection.close();
            throw err;
        }
    }
}
//# sourceMappingURL=transport.js.map