(function (root, factory) {(typeof module === 'object' && module.exports) ? module.exports = factory() : root.ItMerge = factory()}(typeof self !== 'undefined' ? self : this, function () {
"use strict";var ItMerge=(()=>{var y=Object.defineProperty;var N=Object.getOwnPropertyDescriptor;var P=Object.getOwnPropertyNames;var A=Object.prototype.hasOwnProperty;var I=(t,e)=>{for(var r in e)y(t,r,{get:e[r],enumerable:!0})},M=(t,e,r,i)=>{if(e&&typeof e=="object"||typeof e=="function")for(let u of P(e))!A.call(t,u)&&u!==r&&y(t,u,{get:()=>e[u],enumerable:!(i=N(e,u))||i.enumerable});return t};var _=t=>M(y({},"__esModule",{value:!0}),t);var U={};I(U,{default:()=>O});function c(){let t={};return t.promise=new Promise((e,r)=>{t.resolve=e,t.reject=r}),t}var p=class{buffer;mask;top;btm;next;constructor(e){if(!(e>0)||(e-1&e)!==0)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(e),this.mask=e-1,this.top=0,this.btm=0,this.next=null}push(e){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){let e=this.buffer[this.btm];if(e!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}isEmpty(){return this.buffer[this.btm]===void 0}},h=class{size;hwm;head;tail;constructor(e={}){this.hwm=e.splitLimit??16,this.head=new p(this.hwm),this.tail=this.head,this.size=0}calculateSize(e){return e?.byteLength!=null?e.byteLength:1}push(e){if(e?.value!=null&&(this.size+=this.calculateSize(e.value)),!this.head.push(e)){let r=this.head;this.head=r.next=new p(2*this.head.buffer.length),this.head.push(e)}}shift(){let e=this.tail.shift();if(e===void 0&&this.tail.next!=null){let r=this.tail.next;this.tail.next=null,this.tail=r,e=this.tail.shift()}return e?.value!=null&&(this.size-=this.calculateSize(e.value)),e}isEmpty(){return this.head.isEmpty()}};var w=class extends Error{type;code;constructor(e,r){super(e??"The operation was aborted"),this.type="aborted",this.code=r??"ABORT_ERR"}};function E(t={}){return j(r=>{let i=r.shift();if(i==null)return{done:!0};if(i.error!=null)throw i.error;return{done:i.done===!0,value:i.value}},t)}function j(t,e){e=e??{};let r=e.onEnd,i=new h,u,o,f,b=c(),v=async()=>{try{return i.isEmpty()?f?{done:!0}:await new Promise((n,s)=>{o=d=>{o=null,i.push(d);try{n(t(i))}catch(a){s(a)}return u}}):t(i)}finally{i.isEmpty()&&queueMicrotask(()=>{b.resolve(),b=c()})}},x=n=>o!=null?o(n):(i.push(n),u),S=n=>(i=new h,o!=null?o({error:n}):(i.push({error:n}),u)),g=n=>{if(f)return u;if(e?.objectMode!==!0&&n?.byteLength==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return x({done:!1,value:n})},m=n=>f?u:(f=!0,n!=null?S(n):x({done:!0})),z=()=>(i=new h,m(),{done:!0}),L=n=>(m(n),{done:!0});if(u={[Symbol.asyncIterator](){return this},next:v,return:z,throw:L,push:g,end:m,get readableLength(){return i.size},onEmpty:async n=>{let s=n?.signal;if(s?.throwIfAborted(),i.isEmpty())return;let d,a;s!=null&&(d=new Promise((V,k)=>{a=()=>{k(new w)},s.addEventListener("abort",a)}));try{await Promise.race([b.promise,d])}finally{a!=null&&s!=null&&s?.removeEventListener("abort",a)}}},r==null)return u;let l=u;return u={[Symbol.asyncIterator](){return this},next(){return l.next()},throw(n){return l.throw(n),r!=null&&(r(n),r=void 0),{done:!0}},return(){return l.return(),r!=null&&(r(),r=void 0),{done:!0}},push:g,end(n){return l.end(n),r!=null&&(r(n),r=void 0),u},get readableLength(){return l.readableLength},onEmpty:n=>l.onEmpty(n)},u}function R(t){return t[Symbol.asyncIterator]!=null}async function T(t,e){try{await Promise.all(t.map(async r=>{for await(let i of r)e.push(i)})),e.end()}catch(r){e.end(r)}}async function*q(t){let e=E({objectMode:!0});T(t,e).catch(()=>{}),yield*e}function*B(t){for(let e of t)yield*e}function D(...t){let e=[];for(let r of t)R(r)||e.push(r);return e.length===t.length?B(e):q(t)}var O=D;return _(U);})();
return ItMerge}));
